{
  "hash": "949668d9744a03075a22e63b9e21e789",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"Iteration with {purrr}\"\n\ndate-modified: 'today'\ndate-format: long\n\nlicense: CC BY-NC\nbibliography: references.bib\n---\n\n\n::: {.callout-warning collapse=\"true\"}\n## Review the functions page!\n\nIf you have not already read the [functions page](functions.html), do so before reading about {purrr}. The purrr package is about applying functions repetitively. You should have a good idea about what a function is and how to write a custom function.\n:::\n\nFrom the [functions page](functions.html) we learned scant definitions of *functional programming* and *functions*. We also learned about the special conditions of programming with {dplyr}, which demands a working understanding of *environment* and *data* variables.[^1] Now we want to apply our functions, row-by-row, to a data frame. We'll use the [purrr package](https://purrr.tidyverse.org/).\n\n[^1]: Links and footnotes on the [functions page](functions.html) will lead to more detailed information on those topics.\n\n::: callout-tip\n## Rule of thumb\n\nNever feel bad for using a FOR loop.\n:::\n\nRemember that in functional programming we're iterating, or recursing, without using FOR loops. For example, in the [regression page](regression.html#example-of-iterative-modeling-with-nested-categories-of-data), we saw an example of *nesting data frames* by category (i.e. by `gender`). After nesting, we have two subsetted data frames that are embeded within a parent-data-frame. The embedded data frames are contained within a *list-column*.\n\n### `nest()`\n\nWe can subset by gender, creating two new subset data frames that we'll put in a new column with the variable name: *data*. This subsetting is accomplished with the `nest()` function.\n\n::: column-margin\n<iframe width=\"300\" height=\"200\" src=\"https://www.youtube.com/embed/kZf11zbVpr0\" title=\"YouTube video player\" frameborder=\"0\" allow=\"accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share\" allowfullscreen>\n\n</iframe>\n:::\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(moderndive)\nlibrary(broom)\nlibrary(tidyverse)\n\nevals |> \n  janitor::clean_names() |> \n  nest(data = -gender)\n```\n\n::: {.cell-output-display}\n`````{=html}\n<div data-pagedtable=\"false\">\n  <script data-pagedtable-source type=\"application/json\">\n{\"columns\":[{\"label\":[\"gender\"],\"name\":[1],\"type\":[\"fct\"],\"align\":[\"left\"]},{\"label\":[\"data\"],\"name\":[2],\"type\":[\"list\"],\"align\":[\"right\"]}],\"data\":[{\"1\":\"female\",\"2\":\"<tibble[,13]>\"},{\"1\":\"male\",\"2\":\"<tibble[,13]>\"}],\"options\":{\"columns\":{\"min\":{},\"max\":[10]},\"rows\":{\"min\":[10],\"max\":[10]},\"pages\":{}}}\n  </script>\n</div>\n`````\n:::\n:::\n\n\n## `map()`\n\nUsing {purrr} we can apply a function --- such as a linear model regression `lm()` --- over each row of the parent data frame. To do this, we use the `map_` class of functions. I say *class* *of functions*, because `purrr::map_` allows us to define the data-type[^2] returned by the mapped function. For example, sometimes we want to return a *character* data-type (`map_chr`), sometimes an *integer* (`map_int`), sometimes a data frame (`map_df`), etc. In the case of a linear model, which is a *list* data-type, we'll use the generic `map()` function to apply an ***anonymous** function*.\n\n[^2]: A fuller explanation of data types can be found in *R for Data Science* [@wickham2023]\n\n::: column-margin\n<iframe width=\"300\" height=\"200\" src=\"https://www.youtube.com/embed/QgasjZGhWlk\" title=\"YouTube video player\" frameborder=\"0\" allow=\"accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share\" allowfullscreen>\n\n</iframe>\n:::\n\n::: callout-note\n## Anonymous functions\n\nExamples of an anonymous function:\n\n`\\(x) x + 1`\n\n`function(x) x + 1`\n\nUnlike the `add_numbers()` function we composed on the [functions page](functions.html#definition), anonymous functions have no object name. Hence they are **anonymous**. Anonymous functions, sometimes called lambda functions, are a convenience for coders using functional programming languages.\n:::\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmy_subset_df <- evals |> \n  janitor::clean_names() |> \n  nest(my_data = -gender) |> \n  mutate(my_fit_bty = map(my_data, function(my_data) \n                                lm(score ~ bty_avg, data = my_data)\n                         )\n        )\nmy_subset_df\n```\n\n::: {.cell-output-display}\n`````{=html}\n<div data-pagedtable=\"false\">\n  <script data-pagedtable-source type=\"application/json\">\n{\"columns\":[{\"label\":[\"gender\"],\"name\":[1],\"type\":[\"fct\"],\"align\":[\"left\"]},{\"label\":[\"my_data\"],\"name\":[2],\"type\":[\"list\"],\"align\":[\"right\"]},{\"label\":[\"my_fit_bty\"],\"name\":[3],\"type\":[\"list\"],\"align\":[\"right\"]}],\"data\":[{\"1\":\"female\",\"2\":\"<tibble[,13]>\",\"3\":\"<S3: lm>\"},{\"1\":\"male\",\"2\":\"<tibble[,13]>\",\"3\":\"<S3: lm>\"}],\"options\":{\"columns\":{\"min\":{},\"max\":[10]},\"rows\":{\"min\":[10],\"max\":[10]},\"pages\":{}}}\n  </script>\n</div>\n`````\n:::\n:::\n\n\n### Look at the fitted object\n\nWhen we look at the resulting `my_fit_bty` data variable, we see the kind of output we get from `lm()`\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmy_subset_df$my_fit_bty\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[[1]]\n\nCall:\nlm(formula = score ~ bty_avg, data = my_data)\n\nCoefficients:\n(Intercept)      bty_avg  \n    3.95006      0.03064  \n\n\n[[2]]\n\nCall:\nlm(formula = score ~ bty_avg, data = my_data)\n\nCoefficients:\n(Intercept)      bty_avg  \n     3.7666       0.1103  \n```\n\n\n:::\n:::\n\n\nEarlier, we learned to use the `broom::tidy()` function to transform a fitted model --- contained as a *list* data-type --- into a data frame.[^3] For example, we can easily `tidy` the first model which coerces the list data-type into a data frame.\n\n[^3]: Having our regression model wrapped as a data frame means we can use other {dplyr} functions to more easily manipulate our model output.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntidy(my_subset_df$my_fit_bty[[1]])\n```\n\n::: {.cell-output-display}\n`````{=html}\n<div data-pagedtable=\"false\">\n  <script data-pagedtable-source type=\"application/json\">\n{\"columns\":[{\"label\":[\"term\"],\"name\":[1],\"type\":[\"chr\"],\"align\":[\"left\"]},{\"label\":[\"estimate\"],\"name\":[2],\"type\":[\"dbl\"],\"align\":[\"right\"]},{\"label\":[\"std.error\"],\"name\":[3],\"type\":[\"dbl\"],\"align\":[\"right\"]},{\"label\":[\"statistic\"],\"name\":[4],\"type\":[\"dbl\"],\"align\":[\"right\"]},{\"label\":[\"p.value\"],\"name\":[5],\"type\":[\"dbl\"],\"align\":[\"right\"]}],\"data\":[{\"1\":\"(Intercept)\",\"2\":\"3.95005984\",\"3\":\"0.12638672\",\"4\":\"31.25376\",\"5\":\"1.909504e-77\"},{\"1\":\"bty_avg\",\"2\":\"0.03064259\",\"3\":\"0.02570967\",\"4\":\"1.19187\",\"5\":\"2.347757e-01\"}],\"options\":{\"columns\":{\"min\":{},\"max\":[10]},\"rows\":{\"min\":[10],\"max\":[10]},\"pages\":{}}}\n  </script>\n</div>\n`````\n:::\n:::\n\n\n### Named functions\n\nIf we wanted to tidy all the models --- not only the fist model (above) --- then we use the `map` function (again.) This time we **map** a named function, i.e. `broom::tidy()`. We do this row-by-row with `map()`, i.e. **without** using a FOR loop.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmy_subset_df |> \n  mutate(my_fit_bty_tidy = map(my_fit_bty, tidy))\n```\n\n::: {.cell-output-display}\n`````{=html}\n<div data-pagedtable=\"false\">\n  <script data-pagedtable-source type=\"application/json\">\n{\"columns\":[{\"label\":[\"gender\"],\"name\":[1],\"type\":[\"fct\"],\"align\":[\"left\"]},{\"label\":[\"my_data\"],\"name\":[2],\"type\":[\"list\"],\"align\":[\"right\"]},{\"label\":[\"my_fit_bty\"],\"name\":[3],\"type\":[\"list\"],\"align\":[\"right\"]},{\"label\":[\"my_fit_bty_tidy\"],\"name\":[4],\"type\":[\"list\"],\"align\":[\"right\"]}],\"data\":[{\"1\":\"female\",\"2\":\"<tibble[,13]>\",\"3\":\"<S3: lm>\",\"4\":\"<tibble[,5]>\"},{\"1\":\"male\",\"2\":\"<tibble[,13]>\",\"3\":\"<S3: lm>\",\"4\":\"<tibble[,5]>\"}],\"options\":{\"columns\":{\"min\":{},\"max\":[10]},\"rows\":{\"min\":[10],\"max\":[10]},\"pages\":{}}}\n  </script>\n</div>\n`````\n:::\n:::\n\n\nA difference between `my_fit_bty` and `my_fit_bty_tidy` is that `my_fit_bty_tidy` is the model output for the former is a *list*, the later is a *data frame*. Therefore, the parent data frame --- `my_subset_df`--- has a data variable: `my_fit_bty_tidy`, aka `my_subset_df$my_fit_bty_tidy`. my_fit_bty_tidy is a list-column of nested data frames, just like `my_subset_df$data` --- which we nested in the first code-chunk of this page as `evals$data`.\n\nTo un-nest the data frames, use the `unnest()` function.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmy_subset_df |> \n  mutate(my_fit_bty_tidy = map(my_fit_bty, tidy)) |> \n  unnest(my_fit_bty_tidy)\n```\n\n::: {.cell-output-display}\n`````{=html}\n<div data-pagedtable=\"false\">\n  <script data-pagedtable-source type=\"application/json\">\n{\"columns\":[{\"label\":[\"gender\"],\"name\":[1],\"type\":[\"fct\"],\"align\":[\"left\"]},{\"label\":[\"my_data\"],\"name\":[2],\"type\":[\"list\"],\"align\":[\"right\"]},{\"label\":[\"my_fit_bty\"],\"name\":[3],\"type\":[\"list\"],\"align\":[\"right\"]},{\"label\":[\"term\"],\"name\":[4],\"type\":[\"chr\"],\"align\":[\"left\"]},{\"label\":[\"estimate\"],\"name\":[5],\"type\":[\"dbl\"],\"align\":[\"right\"]},{\"label\":[\"std.error\"],\"name\":[6],\"type\":[\"dbl\"],\"align\":[\"right\"]},{\"label\":[\"statistic\"],\"name\":[7],\"type\":[\"dbl\"],\"align\":[\"right\"]},{\"label\":[\"p.value\"],\"name\":[8],\"type\":[\"dbl\"],\"align\":[\"right\"]}],\"data\":[{\"1\":\"female\",\"2\":\"<tibble[,13]>\",\"3\":\"<S3: lm>\",\"4\":\"(Intercept)\",\"5\":\"3.95005984\",\"6\":\"0.12638672\",\"7\":\"31.253756\",\"8\":\"1.909504e-77\"},{\"1\":\"female\",\"2\":\"<tibble[,13]>\",\"3\":\"<S3: lm>\",\"4\":\"bty_avg\",\"5\":\"0.03064259\",\"6\":\"0.02570967\",\"7\":\"1.191870\",\"8\":\"2.347757e-01\"},{\"1\":\"male\",\"2\":\"<tibble[,13]>\",\"3\":\"<S3: lm>\",\"4\":\"(Intercept)\",\"5\":\"3.76655081\",\"6\":\"0.09277601\",\"7\":\"40.598326\",\"8\":\"5.315410e-116\"},{\"1\":\"male\",\"2\":\"<tibble[,13]>\",\"3\":\"<S3: lm>\",\"4\":\"bty_avg\",\"5\":\"0.11026114\",\"6\":\"0.02066473\",\"7\":\"5.335717\",\"8\":\"2.038108e-07\"}],\"options\":{\"columns\":{\"min\":{},\"max\":[10]},\"rows\":{\"min\":[10],\"max\":[10]},\"pages\":{}}}\n  </script>\n</div>\n`````\n:::\n:::\n\n\nAnd now we have fitted model data, contained as tidy-data, within a data frame, which we can manipulate further with other tidyverse functions. For example, using dplyr functions it's easy to make a pipeline to look at the p-values of `bty_avg`, by `gender`.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmy_subset_df |> \n  mutate(my_fit_bty_tidy = map(my_fit_bty, tidy)) |> \n  unnest(my_fit_bty_tidy) |> \n  select(gender, term, p.value) |> \n  filter(term == \"bty_avg\")\n```\n\n::: {.cell-output-display}\n`````{=html}\n<div data-pagedtable=\"false\">\n  <script data-pagedtable-source type=\"application/json\">\n{\"columns\":[{\"label\":[\"gender\"],\"name\":[1],\"type\":[\"fct\"],\"align\":[\"left\"]},{\"label\":[\"term\"],\"name\":[2],\"type\":[\"chr\"],\"align\":[\"left\"]},{\"label\":[\"p.value\"],\"name\":[3],\"type\":[\"dbl\"],\"align\":[\"right\"]}],\"data\":[{\"1\":\"female\",\"2\":\"bty_avg\",\"3\":\"2.347757e-01\"},{\"1\":\"male\",\"2\":\"bty_avg\",\"3\":\"2.038108e-07\"}],\"options\":{\"columns\":{\"min\":{},\"max\":[10]},\"rows\":{\"min\":[10],\"max\":[10]},\"pages\":{}}}\n  </script>\n</div>\n`````\n:::\n:::\n\n\nWhen we combine linear modeling with other broom functions such as `glance()` and `augment()`, then we can build on our analysis and data manipulation.\n\n## Anonymous functions\n\nAnonymous functions have no name. Unlike a **named** function (e.g. `broom::tidy` above, or `make_scatterplot` from the [functions page](functions.html)). Below we **map** an anonymous function within `map()`. The first argument to map is a *list* **or** *data frame*. The next argument can be a named function **or** an anonymous function. In the example below, the anonymous function produces a scatter plot with a regression line.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmy_subset_df_with_plots <- my_subset_df |> \n  mutate(my_plot = map(my_data, function(my_data) \n    my_data |> \n      ggplot(aes(bty_avg, score)) + \n      geom_point() +\n      geom_smooth(method = lm, se = FALSE, formula = y ~ x)\n                      )\n         )\nmy_subset_df_with_plots\n```\n\n::: {.cell-output-display}\n`````{=html}\n<div data-pagedtable=\"false\">\n  <script data-pagedtable-source type=\"application/json\">\n{\"columns\":[{\"label\":[\"gender\"],\"name\":[1],\"type\":[\"fct\"],\"align\":[\"left\"]},{\"label\":[\"my_data\"],\"name\":[2],\"type\":[\"list\"],\"align\":[\"right\"]},{\"label\":[\"my_fit_bty\"],\"name\":[3],\"type\":[\"list\"],\"align\":[\"right\"]},{\"label\":[\"my_plot\"],\"name\":[4],\"type\":[\"list\"],\"align\":[\"right\"]}],\"data\":[{\"1\":\"female\",\"2\":\"<tibble[,13]>\",\"3\":\"<S3: lm>\",\"4\":\"<S3: gg>\"},{\"1\":\"male\",\"2\":\"<tibble[,13]>\",\"3\":\"<S3: lm>\",\"4\":\"<S3: gg>\"}],\"options\":{\"columns\":{\"min\":{},\"max\":[10]},\"rows\":{\"min\":[10],\"max\":[10]},\"pages\":{}}}\n  </script>\n</div>\n`````\n:::\n:::\n\n\nAnd now we can pull those plots\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmy_subset_df_with_plots |> \n  pull(my_plot)\n```\n:::\n\n::: {.cell layout-ncol=\"2\"}\n::: {.cell-output-display}\n![Female](purrr_files/figure-html/unnamed-chunk-10-1.png){width=672}\n:::\n\n::: {.cell-output-display}\n![Male](purrr_files/figure-html/unnamed-chunk-10-2.png){width=672}\n:::\n:::\n\n\n## `map2()` & `pmap()`\n\nIf you have more than one argument to map, you can use functions such as `map2()` or `pmap()`. An example of `map2()` can be found on the [regression page](regression.html#example-of-iterative-modeling-with-nested-categories-of-data).\n\n```{{r}} \n# Example of mapping a anonymous function with two variables.\n\nmap2(my_df, my_plot, gender, function(x, y) { x + labs(title = str_to_title(y)) } )\n\n# x refers to the second argument of map2, i.e. `my_plot`\n\n# y refers to the third argument, i.e. `gender`\n\n```\n\n \n",
    "supporting": [
      "purrr_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {
      "include-in-header": [
        "<link href=\"site_libs/pagedtable-1.1/css/pagedtable.css\" rel=\"stylesheet\" />\n<script src=\"site_libs/pagedtable-1.1/js/pagedtable.js\"></script>\n"
      ]
    },
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}